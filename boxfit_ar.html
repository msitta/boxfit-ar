<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BoxFit AR (WebXR)</title>
  <!-- Babylon + GUI + GridMaterial -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.min.js"></script>
  <style>
    :root {
      --ui-bg: rgba(0,0,0,.50);
      --ui-fg: #fff;
      --accent1: #ffd54f;
      --accent2: #64ffda;
      --accent3: #90caf9;
    }
    * { box-sizing:border-box; }
    html, body { width:100%; height:100%; margin:0; background:#111; }
    #canvas { width:100%; height:100%; touch-action:none; display:block; }
    #ui {
      position: fixed; left: 8px; right: 8px; bottom: 8px;
      padding: 10px; border-radius: 12px; color: var(--ui-fg);
      background: var(--ui-bg); backdrop-filter: blur(6px);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .row { display:flex; align-items:center; gap:6px; flex-wrap:nowrap; }
    .row input {
      flex: 1 1 0; min-width: 0;
      /* largura proporcional: tente caber numa linha em telas ~360–440px */
      width: 22vw; max-width: 120px;
      padding: 6px 8px; border-radius: 10px; border:1px solid #444;
      background:#222; color:#fff; font-size: 12px;
    }
    .row button {
      padding: 8px 12px; border-radius: 10px; border:0; font-weight:600; cursor:pointer;
      color:#111;
    }
    #start { background: var(--accent1); }
    #place { background: var(--accent2); }
    #snap  { background: var(--accent3); }
    #msg { margin-top:6px; font-size:12px; opacity:.9; }
    @media (max-width: 360px) {
      /* fallback: se realmente não couber, permite quebrar linha */
      .row { flex-wrap: wrap; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div class="row" id="fields">
      <!-- Apenas LIMITES (placeholders no lugar de labels) -->
      <input id="maxW" type="number" min="1" value="55" placeholder="Limite L (cm)">
      <input id="maxH" type="number" min="1" value="35" placeholder="Limite A (cm)">
      <input id="maxD" type="number" min="1" value="25" placeholder="Limite P (cm)">
    </div>
    <div class="row" style="margin-top:8px;">
      <button id="start">Iniciar AR</button>
      <button id="place">Posicionar caixa</button>
      <button id="snap">Foto</button>
    </div>
    <div id="msg">Toque em “Iniciar AR”, mova o celular para “varrer” o piso e aguarde a grade aparecer.</div>
  </div>

<script>
(async function(){
  const canvas = document.getElementById('canvas');
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true }, true);
  const scene  = new BABYLON.Scene(engine);
  scene.useRightHandedSystem = true;
  scene.clearColor = new BABYLON.Color4(0,0,0,0);

  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.6;

  // Caixa = "gabarito" (limites) — sem cores de "aprovação/reprovação"
  const boxMat = new BABYLON.StandardMaterial("boxMat", scene);
  boxMat.alpha = 0.35;
  boxMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.9); // ciano suave

  const box = BABYLON.MeshBuilder.CreateBox("box", { size: 1 }, scene);
  box.isVisible = false;
  box.material = boxMat;

  // Grade no chão (alinhada ao hit); células de 10 cm
  const grid = BABYLON.MeshBuilder.CreateGround("grid", { width: 1.2, height: 1.2, subdivisions: 2 }, scene);
  const gridMat = new BABYLON.GridMaterial("gridMat", scene);
  gridMat.gridRatio = 0.1;           // 0.1 m = 10 cm por célula
  gridMat.mainColor = new BABYLON.Color3(0.8, 0.8, 0.8);
  gridMat.lineColor = new BABYLON.Color3(0.35, 0.35, 0.35);
  gridMat.opacity = 0.6;
  grid.material = gridMat;
  grid.isVisible = false;

  const $ = (id)=>document.getElementById(id);
  const maxW=$("maxW"), maxH=$("maxH"), maxD=$("maxD");
  const startBtn=$("start"), placeBtn=$("place"), snapBtn=$("snap"), msg=$("msg");

  let xrHelper=null, xr=null;
  let lastHitPose=null, currentAnchor=null;
  let hitsCount=0;

  function setStatus(t){ msg.textContent = `${t} | hits: ${hitsCount}`; }

  function setBoxFromLimits(){
    const w = Math.max(1, Number(maxW.value||0)) / 100.0; // cm -> m
    const h = Math.max(1, Number(maxH.value||0)) / 100.0;
    const d = Math.max(1, Number(maxD.value||0)) / 100.0;
    box.scaling.set(w, h, d);
    box.position.y = h / 2.0; // "encosta" no chão
  }
  setBoxFromLimits();
  [maxW,maxH,maxD].forEach(e=>e.addEventListener('input', setBoxFromLimits));

  // === inicia sessão XR com hit-test (estável) e features opcionais ===
  let hitTestFeature = null, anchorsFeature = null, transientFeature = null;

  async function startXR(){
    if (xrHelper?.baseExperience?.isInXR) return; // evita reentrar

    xrHelper = await scene.createDefaultXRExperienceAsync({
      uiOptions: { sessionMode: "immersive-ar" },
      optionalFeatures: true
    });

    await xrHelper.baseExperience.enterXRAsync("immersive-ar", "unbounded", xrHelper.renderTarget, {
      requiredFeatures: ["hit-test"], // base do posicionamento no WebXR/Chrome
      optionalFeatures: ["local-floor", "anchors", "light-estimation"] // melhora alinhamento/realismo
    });

    xr = xrHelper.baseExperience;
    const fm = xr.featuresManager;

    // Habilita uma única vez
    hitTestFeature = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
      entityTypes: ["plane","point"]
    });
    anchorsFeature = fm.enableFeature(BABYLON.WebXRFeatureName.ANCHOR_SYSTEM, "latest");
    fm.enableFeature(BABYLON.WebXRFeatureName.LIGHT_ESTIMATION, "latest");

    // Transient hit-test (fallback por toque) — instanciado UMA vez
    transientFeature = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
      transientHitTest: true
    });

    // Atualiza grade/retículo com o hit contínuo
    hitTestFeature.onHitTestResultObservable.add((results) => {
      hitsCount = results?.length || 0;
      if (!results || results.length === 0) {
        lastHitPose = null;
        grid.isVisible = false;
        setStatus("Procure textura/varra o piso...");
        return;
      }
      const hit = results[0];
      lastHitPose = {
        position: hit.position.clone(),
        rotationQuaternion: hit.rotationQuaternion.clone()
      };
      // Grade aparece alinhada ao piso
      grid.position.copyFrom(hit.position);
      grid.rotationQuaternion = hit.rotationQuaternion;
      grid.isVisible = true;
      setStatus("Piso detectado");
    });

    // Fallback: um toque força um hit transiente
    scene.onPointerDown = () => {
      try {
        const tHits = transientFeature.getHitTestResults?.() || [];
        if (tHits.length > 0) {
          const hit = tHits[0];
          lastHitPose = {
            position: hit.position.clone(),
            rotationQuaternion: hit.rotationQuaternion.clone()
          };
          grid.position.copyFrom(hit.position);
          grid.rotationQuaternion = hit.rotationQuaternion;
          grid.isVisible = true;
          setStatus("Hit por toque");
        }
      } catch(e) { /* silencioso */ }
    };

    setStatus("AR iniciado — varra o piso até a grade aparecer");
  }

  startBtn.onclick = async () => {
    try { await startXR(); }
    catch(e){ console.error(e); setStatus("Falha ao iniciar AR. Verifique HTTPS/perm. de câmera/Chrome."); }
  };

  placeBtn.onclick = async () => {
    if (!xr || !lastHitPose) { setStatus("Aponte/toque no piso até a grade aparecer."); return; }
    try {
      // remove âncora anterior
      if (currentAnchor) { currentAnchor.detach(); currentAnchor = null; }

      setBoxFromLimits();
      box.isVisible = true;

      if (anchorsFeature) {
        const a = await anchorsFeature.addAnchorAtPositionAndRotation(
          lastHitPose.position, lastHitPose.rotationQuaternion
        );
        if (a) {
          currentAnchor = a;
          a.attachedNode = box;
          setStatus("Caixa ancorada");
          return;
        }
      }
      // fallback sem âncora
      box.position.copyFrom(lastHitPose.position);
      box.rotationQuaternion = lastHitPose.rotationQuaternion.clone();
      setStatus("Caixa posicionada (sem âncora)");
    } catch (e) {
      console.error(e);
      setStatus("Não foi possível posicionar. Tente novamente.");
    }
  };

  snapBtn.onclick = () => {
    try {
      const data = canvas.toDataURL("image/png");
      const a = document.createElement('a'); a.href = data; a.download = `boxfit_ar_${Date.now()}.png`; a.click();
      setStatus("Imagem salva");
    } catch (e) { setStatus("Falha ao capturar imagem."); }
  };

  engine.runRenderLoop(()=>scene.render());
  window.addEventListener('resize', ()=>engine.resize());
})();
</script>
</body>
</html>
