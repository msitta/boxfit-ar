<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BoxFit AR (WebXR MVP)</title>
  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#111; }
    #ui {
      position: fixed; left: 8px; right: 8px; bottom: 8px;
      background: rgba(0,0,0,.55); color:#fff; backdrop-filter: blur(6px);
      border-radius: 12px; padding: 10px; font-family: system-ui, sans-serif;
    }
    #ui label { font-size: 12px; opacity:.9; }
    #ui input { width: 70px; padding:6px; margin-right:8px; border-radius:8px; border:1px solid #444; background:#222; color:#fff; }
    #ui button {
      padding:8px 12px; margin-right:6px; border-radius:10px; border:0; color:#111; font-weight:600; cursor:pointer;
    }
    #start { background:#ffd54f; }
    #place { background:#64ffda; }
    #snap  { background:#90caf9; }
    #msg   { font-size:12px; margin-top:6px; opacity:.9; }
    #canvas { width:100%; height:100%; touch-action:none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div style="display:flex;flex-wrap:wrap;align-items:center;gap:6px;">
      <label>L(cm)</label><input id="inW" type="number" min="1" value="55">
      <label>A(cm)</label><input id="inH" type="number" min="1" value="35">
      <label>P(cm)</label><input id="inD" type="number" min="1" value="25">
      <label>Limite L</label><input id="maxW" type="number" min="1" value="55">
      <label>Limite A</label><input id="maxH" type="number" min="1" value="35">
      <label>Limite P</label><input id="maxD" type="number" min="1" value="25">
    </div>
    <div style="margin-top:8px;">
      <button id="start">Iniciar AR</button>
      <button id="place">Colocar no piso</button>
      <button id="snap">Foto</button>
    </div>
    <div id="msg">Dica: mova o celular para o Chrome encontrar o piso (retículo aparece).</div>
  </div>

<script>
(async function(){
  const canvas = document.getElementById('canvas');
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true }, true);
  const scene  = new BABYLON.Scene(engine);
  scene.useRightHandedSystem = true;
  scene.clearColor = new BABYLON.Color4(0,0,0,0);

  // Luz básica + material da caixa
  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene); hemi.intensity = 0.6;
  const boxMat = new BABYLON.StandardMaterial("boxMat", scene); boxMat.alpha = 0.35; boxMat.diffuseColor = new BABYLON.Color3(0.2,0.9,0.6);

  // Caixa e retículo
  const box = BABYLON.MeshBuilder.CreateBox("box", { size: 1 }, scene); box.isVisible = false; box.material = boxMat;
  const reticle = BABYLON.MeshBuilder.CreateTorus("reticle", { diameter:0.2, thickness:0.003, tessellation:64 }, scene);
  const retMat = new BABYLON.StandardMaterial("retMat", scene); retMat.emissiveColor = new BABYLON.Color3(1,0.9,0.2);
  reticle.material = retMat; reticle.isVisible = false;

  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0,1.6,0), scene);

  // UI
  const $ = (id)=>document.getElementById(id);
  const inW=$("inW"), inH=$("inH"), inD=$("inD"), maxW=$("maxW"), maxH=$("maxH"), maxD=$("maxD");
  const startBtn=$("start"), placeBtn=$("place"), snapBtn=$("snap"), msg=$("msg");

  let xrHelper, xr; let lastHitPose = null; let currentAnchor = null; let hitsCount = 0;

  function setStatus(t){ msg.textContent = `${t} | hits: ${hitsCount}`; }

  function setBoxFromInputs(){
    const w = Math.max(1, Number(inW.value||0))/100.0;
    const h = Math.max(1, Number(inH.value||0))/100.0;
    const d = Math.max(1, Number(inD.value||0))/100.0;
    const fits = (Number(inW.value)<=Number(maxW.value))&&(Number(inH.value)<=Number(maxH.value))&&(Number(inD.value)<=Number(maxD.value));
    boxMat.diffuseColor = fits ? new BABYLON.Color3(0.2,0.9,0.6) : new BABYLON.Color3(0.95,0.25,0.25);
    box.scaling.set(w,h,d);
    box.position.y = h/2.0; // apoia no piso
  }
  setBoxFromInputs();
  [inW,inH,inD,maxW,maxH,maxD].forEach(e=>e.addEventListener('input', setBoxFromInputs));

  // === NOVO: sessão XR com features ajustadas ===
  async function startXR(){
    xrHelper = await scene.createDefaultXRExperienceAsync({
      uiOptions: { sessionMode: "immersive-ar" },
      optionalFeatures: true
    });

    // Entra em AR especificando recursos
    await xrHelper.baseExperience.enterXRAsync("immersive-ar", "unbounded", xrHelper.renderTarget, {
      requiredFeatures: ["hit-test"],
      optionalFeatures: ["local-floor","anchors","light-estimation"] // tenta local-floor
    });

    const fm = xrHelper.baseExperience.featuresManager;
    // Light estimation (opcional)
    fm.enableFeature(BABYLON.WebXRFeatureName.LIGHT_ESTIMATION, "latest");

    // HIT TEST contínuo (viewer space)
    const hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
      entityTypes: ["plane","point"]
    });

    // Âncoras (opcional)
    const anchors = fm.enableFeature(BABYLON.WebXRFeatureName.ANCHOR_SYSTEM, "latest");

    setStatus("AR iniciado — procurando piso...");

    hitTest.onHitTestResultObservable.add((results)=>{
      hitsCount = results?.length || 0;
      if (!results || results.length===0){
        reticle.isVisible = false; lastHitPose = null; setStatus("Movimente o celular para varrer o piso...");
        return;
      }
      const hit = results[0];
      reticle.isVisible = true;
      reticle.position.copyFrom(hit.position);
      reticle.rotationQuaternion = hit.rotationQuaternion;
      lastHitPose = { position: hit.position.clone(), rotationQuaternion: hit.rotationQuaternion.clone() };
      setStatus("Piso detectado");
    });

    // === NOVO: fallback por toque (transient hit-test) ===
    scene.onPointerDown = async () => {
      try {
        const transient = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", { transientHitTest:true });
        const tHits = transient.getHitTestResults?.() || [];
        if (tHits.length>0){
          const hit = tHits[0];
          lastHitPose = { position: hit.position.clone(), rotationQuaternion: hit.rotationQuaternion.clone() };
          reticle.isVisible = true;
          reticle.position.copyFrom(hit.position);
          reticle.rotationQuaternion = hit.rotationQuaternion;
          setStatus("Hit por toque");
        }
      } catch(_) {}
    };

    // Expõe helpers para “place”
    return { anchors };
  }

  let anchorsFeature = null;

  startBtn.onclick = async ()=>{
    try {
      const r = await startXR();
      anchorsFeature = r.anchors;
    } catch(e){
      console.error(e); setStatus("Falha ao iniciar AR. Verifique HTTPS/Permissão de câmera/Chrome atualizado.");
    }
  };

  placeBtn.onclick = async ()=>{
    if (!lastHitPose){ setStatus("Aponte para o piso até aparecer o retículo (ou toque uma vez na tela)."); return; }
    if (currentAnchor){ currentAnchor.detach(); currentAnchor = null; }
    setBoxFromInputs(); box.isVisible = true;

    // Tenta ancorar (opcional)
    if (anchorsFeature){
      try {
        const a = await anchorsFeature.addAnchorAtPositionAndRotation(lastHitPose.position, lastHitPose.rotationQuaternion);
        if (a){ currentAnchor = a; a.attachedNode = box; setStatus("Caixa ancorada"); return; }
      } catch(_) {}
    }
    // Fallback sem âncora
    box.position.copyFrom(lastHitPose.position);
    box.rotationQuaternion = lastHitPose.rotationQuaternion.clone();
    setStatus("Caixa posicionada (sem âncora)");
  };

  snapBtn.onclick = ()=>{
    try{
      const data = canvas.toDataURL("image/png");
      const a = document.createElement('a'); a.href=data; a.download=`boxfit_ar_${Date.now()}.png`; a.click();
      setStatus("Imagem salva");
    }catch(_){ setStatus("Não foi possível capturar a imagem."); }
  };

  engine.runRenderLoop(()=>scene.render());
  addEventListener('resize', ()=>engine.resize());
})();
</script>
</body>

</html>
